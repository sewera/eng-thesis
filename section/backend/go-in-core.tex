\subsection{Go in core}\label{sec:go-in-core}

Go is quickly gaining popularity among developers,
with its great tooling
and a state-of-the-art standard library.
It is an excellent language for writing microservices.
Its focus on this one task
and pragmatism in adding features to the language by its authors,
resulted in an easy to understand and use,
yet very powerful set of tools.

\subsubsection{Motivation}\label{sec:motivation}

When choosing the right language for the project,
I focused on finding the right tool
for the application and developer experience.

I wanted \texttt{notipie} to be a high-performance microservice,
so I did not take interpreted languages
like Python or JavaScript into consideration.
I mostly considered Java, Kotlin, Rust, and Go.

Java, although popular, does not have the greatest developer experience.
Things like \texttt{equals} and \texttt{hashCode}
are unnecessary bloat in the code.
Project Lombok~\cite{zwitserloot_project_2022} fixes some of them,
but the tooling is limited to IntelliJ,
you have to download a lot of libraries for dealing with JSON,
create your own code style guide,
and perform a fair bit of setup.

Kotlin, far better than Java,
but also locked-in to IntelliJ with tooling,
was an interesting option for me, but not ideal.

Rust was too low-level for my application.
Explicit memory management, although performant,
was simply too verbose and work-intensive for my use case.

Go was a perfect option.
A plethora of great tooling,
like first-party Go plugin for VSCode, GoLand from JetBrains,
community plugins for Neovim,
all working great and providing a good developer experience.
Furthermore, extraordinary performance of the tooling itself,
with tests running in under a second, super-fast compiler,
one of the best standard libraries I have seen,
and overall simplicity of the language, made the choice obvious.

\subsubsection{How did Go make the development easier}\label{sec:how-did-go-make-the-development-easier}

\paragraph*{Built-in language features}\label{par:built-in-language-features}

The features that helped the most during development
were channels and \emph{goroutines},
coroutines automatically managed by the Go runtime.
The idea behind those was very simple to understand,
and working with concurrent programming was a lot easier.

\paragraph*{Goroutines and channels}\label{par:goroutines-and-channels}

Among of the best features of the Go language lay goroutines and channels.
They make concurrent programming a lot easier, compared to other languages.
I used both goroutines and channels
for inter-object communication in \texttt{domain} package.

For example, in {tag.go}~(appendix~\ref{apx:concurrency-in-go}),
after the Tag object is created,
the constructor calls
the \texttt{start} method~(listing~\ref{lst:start-method-in-tag}).
It is running a new goroutine for every Tag instance,
enabling them to asynchronously communicate with other objects.

The Tag was a particularly special case,
in which I had to solve
the Notification duplication problem,
described in detail in section~\ref{sec:tag-technicalities}

\paragraph*{Standard library}\label{par:standard-library}

Standard \texttt{testing} package~\cite{cox_testing_2022} provided
a unified, and simple tooling for testing.
I did not have to think anything about test setup.
No custom scripts, third-party libraries, or IDE setup.
All I needed to do was to name a file with a \texttt{\_test.go} suffix,
write a function starting with \texttt{Test},
and run \texttt{go\ test\ ./...}.
Both VSCode with Go plugin and GoLand
automatically picked up the test setup,
and I was ready to develop with TDD.

Standard \texttt{net/http} package~\cite{cox_http_2022} provides everything
needed for setting up REST endpoints.
Although I used Gin~\cite{martinez-almeida_gin_2022} for this,
due to a simpler interface,
I used status codes and HTTP client implementation from \texttt{net/http}.

\paragraph*{Refactoring to the standards}\label{par:refactoring-to-the-standards}

During this project,
I refactored my functions to better suit
the Go standard library.

For instance,
in commit \texttt{00547cd}\footfullcite{sewera_chorecoreproducer_2022},
I refactored the \texttt{ToJSON} method
to better suit the standard signatures
(appendix~\ref{apx:method-signature-refactoring-in-go}),
i.e. to return the byte array and error,
just like the \texttt{Marshal} method
from the \texttt{json} package~\cite{cox_json_2022}
in the standard library.

\paragraph*{Third-party libraries}\label{par:third-party-libraries}

Gin was great for writing REST endpoints,
with \texttt{gin.Context} having easy access to
standard-library-compatible fields,
making it easily pluggable to other third-party libraries,
like Gorilla WebSocket~\cite{burd_gorilla_2022}.

Zap~\cite{shah_zap_2022} provided a reliable
and performant way to log things in the backend.
Structured logging,
straightforward syntax,
automatic serialization to JSON in production mode,
and human-readable format in debug mode,
paired with low or zero-allocation overhead,
made it a perfect choice for logging in a microservice.

\addtocategory{commit}{sewera_chorecoreproducer_2022}
