\subsubsection{Format}\label{sec:protocol-format}

When I was choosing the right format
for the notifications,
I took into consideration two options:
binary and plain text.
I chose plain text,
because portability was very important to me.
I wanted to have the protocol able to run
between different processor architectures,
and not think about endianness\footnote{
  Endianness is the attribute of a system
  that indicates whether integers are represented with
  the most significant byte
  stored at the lowest address (big endian)
  or at the highest address (little endian)~\cite{adiga_how_2007}.
}.
I also did not want to specify any of the lower
ISO/OSI\footnote{
  \acs{ISO} -- \acl{ISO}; \acs{OSI} -- \acl{OSI}
} layers~\cite{international_organization_for_standardization_isoiec_1994}.
My application does not need to know about them,
and it should work regardless of the network protocols
in the Transport or Network Layer.

Then, I wanted to use a format
that was popular for network data exchange.
The candidates were \ac{XML} and \ac{JSON}.
I did not want to go with \ac{XML},
as the parsing is not that easy,
readability is very poor,
and the popularity is dropping
in favor of \ac{JSON}.
I chose \ac{JSON}
because of its support by \ac{TS} and Go,
either as a language feature,
or in a standard library.
I also chose \ac{JSON} for the push response
containing App \ac{ID}
for consistency.

I decided to support both \ac{JSON} and \ac{YAML}
in the configuration files for the producer,
including the notification template\footnote{
  More on the configuration files and templates
  for the producer
  in section~\ref{sec:configuration-and-notification-templates}.
}.
\ac{YAML} is favorable in configuration files,
so I wanted to provide a uniform
format for a configuration file
and a template.
\ac{YAML}, however,
does not go through the network
anywhere in Notipie.
