\subsection{UI networking}\label{sec:ui-networking}

The nature of notifications required me to use
both REST data fetching and asynchronous data pushes from the backend.
For the latter, I decided to use WebSockets,
a standard defined in RFC6455~\cite{fette_rfc6455_2011}, and
RxJS~\cite{lesh_rxjs_2022}, an implementation of
ReactiveX library~\cite{gross_reactivex_2021}.

\subsubsection{REST data fetching}\label{sec:rest-data-fetching}

I used simple REST~\cite{perrier_rest_2022} requests
for fetching the notifications
that are already on the backend server.
The standard Fetch browser API~\cite{perrier_fetch_2022}
was sufficient for the task.

\subsubsection{Reactive Raven}\label{sec:reactive-raven}

This project~\cite{sewera_reactive_2022} was an experiment
on using RxJS for all real-time data fetching,
enabling the separation of concerns in the code,
and decoupling the state management implementation
from the networking implementation.

When searching for the optimal solution for pushing the data to the UI,
I came across two major solutions:

\begin{itemize}
      \item
            Redux Thunk~\cite{gaeraon_redux_2022-1} --
            enough for fetching data on user interaction,
            e.g., on a button click,
            but it provides virtually full implementation lock-in
            to the Redux store, and very little separation of concerns.
            Fetching data is an action dispatched on a store,
            so external communication and storing data are dependent on each other.
      \item
            Redux Saga~\cite{elouafi_redux_2022} --
            good for managing side effects with plain JavaScript,
            but it uses generator functions
            that yield a different type every time,
            so it is very problematic to use with strict TypeScript.
\end{itemize}

Both thunks and sagas did not provide the separation of concerns
I wanted to achieve.
Fetching or acting upon pushed data
is a different concern than storing it.

As a user,
I should not have to dispatch an action on a store
when I want to fetch data.
Of course, the data can be immediately stored after fetching,
but this behavior should be injected later,
so that there is no store implementation lock-in.

This separation of concerns enabled me to
migrate from Redux to Zustand as my \emph{store} implementation,
as described in the next section.
