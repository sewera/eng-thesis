\subsection{E2E Testing}\label{sec:e2e-testing}

E2E testing is a way to test the whole solution.
Everything,
from setting up the application stack
to the complete set of interactions
that a user can perform,
both from the perspective of notification producer,
and the Notipie UI in the web browser.
E2E testing, however, does not provide
the best bug finding capabilities.
Therefore,
I developed more manual testing scenarios,
which include portions of the system
that are bigger than unit tests,
but more granular than a full E2E test.

There are two ways of E2E testing,
manual and automatic.
I chose the former,
because writing automatic tests
require a complex setup,
a new framework like Selenium~\cite{steward_selenium_2022},
and a whole other project to maintain.
E2E test automation is of substantial advantage
for bigger projects, however,
my project is well tested with
unit tests,
integration tests, and
snapshot tests\footnote{
  Snapshot testing is a frontend-specific term
  explained in section~\ref{sec:ui-testing}.
}.
Not every task has to be automated
if it is not executed that often
or if the cost of automation outgrows
the payoffs~\cite{millett_patterns_2015}.
All of those automatic tests
raised my confidence in the project high enough
that I did not have to manually test
the application very often.

Despite that,
I created two manual testing utilities,
which helped me with development
of frontend and backend components independently,
a test notifications server
and a test WebSocket client.
I chose to write both of them in TypeScript,
with as little code as possible;
first not to introduce another language
to the project, like Python,
and second to reduce the overhead
of a statically-typed language
for such a simple, non-critical task.

\subsubsection{Test Notifications Server}\label{sec:test-notifications-server}

The test notifications server
is a very simple server that sends
randomly-generated notifications to the UI.
It can send an initial batch of notifications
when the UI calls the endpoint synchronously,
but it also can accept a WS connection
and send one notification at a time asynchronously,
on a press of the \textit{Enter} key.

The server itself is written
using Express~\cite{holowaychuck_express_2022},
a lightweight HTTP framework.
The random notification generation
is done with a help of Faker~\cite{marak_faker_2022},
a JS library for generating fake,
but realistically-looking data.
I used it for checking if the UI
is wired up properly,
when I did not have
the notification producer
implementation in place.
An example of randomly-generated notifications
created by this test server is illustrated
in section~\ref{sec:frontend},
figure~\ref{fig:notipie-ui-dark}.

\subsubsection{Test WebSocket Client}\label{sec:test-ws-client}

The test WS client
is a simple client that connects
to a hard-coded URL on start,
sets up the WS connection,
and logs everything that is pushed to it.
It also closes the connection before stopping.
For the implementation,
I used the built-in standard WS implementation
in Node~\cite{trott_node_2022}.

I used this test client
to check if the backend properly
sets up the connection,
creates the client object,
sends the data,
and destroys the object properly
after the client disconnects.
It was mainly useful for the Notipie backend,
but I also used it to debug the backend
of Reactive Raven\footnote{
  Reactive Raven is describe in more detail in section~\ref{sec:reactive-raven}.
}.
