\subsection{What went right}\label{sec:what-went-right}

I am happy that I have set up a \ac{CI} pipeline
in Github Actions~\cite{github_inc_github_2022-1}
pretty early in the project,
before I even acknowledged how important it is
when reading Kent Beck's book on \ac{XP}~\cite{beck_extreme_2004}.
It significantly sped up my development cycle,
and~provided me with invaluable feedback,
even when I pushed the code to the server
and turned off my computer.
The \ac{CI} pipeline, however,
would be of no use had I not written
any automated tests.
The most comprehensive test suite,
which checks the most crucial paths
in backend,
was the integration test suite,
listed in appendix~\ref{apx:integration-test-core}.

As I was writing the core domain code,
I followed another Kent Beck's advice,
and I left breaking tests between commits.
It was an advice for single-developer projects
utilizing \ac{TDD}~\cite{beck_test-driven_2002}.
When there are at least two developers,
it is much easier to keep track of what is going on.
When I get distracted,
I lose focus and current context of the code.
In pair programming,
the second programmer can take over this context
and maintain continuity.
In a single-developer project,
the~foregoing failing tests act as a second programmer
in this regard,
and they mark a clear place
to take up where I left off.

I am very proud of my experiments
on the code,
like Reactive Raven~\cite{sewera_reactive_2022},
explained in section~\ref{sec:reactive-raven},
or connecting snapshot testing
with a \ac{CSS} utility library
to avoid slow visual tests,
which is explained in section~\ref{sec:ui-testing}.

Not including a database in the \ac{MVP}
was also the right choice.
I noticed in my professional career that
deciding which database is right for the application early on,
usually produces a lot of problems.
For instance,
if chosen database has insufficient performance,
the work needed for that database setup is wasted.
On~the other hand,
when we choose a database tailored for performance,
we might need to handle a more complex setup.
If our application turns out to be of low throughput,
said more complex setup and additional maintenance
is also wasted time,
as a simpler one would suffice.
We should postpone the decisions as far as we can,
because only then we have the most information
and knowledge to make one~\cite{erder_principle_2016}.
So it was not dictated
by my reluctancy to add one,
but rather an informed decision
to first measure the real-world traffic
in my application,
and then add a proper database,
based on facts, not assumptions.
What is more,
even if the server fails and has to be restarted,
a user with Notipie open in their browser
will still see all the notifications,
thanks to the store implementation in the \ac{UI}\footnote{
  The store,
  which is a container for application state in the \ac{UI},
  is described in detail in section~\ref{sec:state-management-in-ui}.
}.
