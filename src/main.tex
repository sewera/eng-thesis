\hypertarget{project-management}{%
	\section{Project management}\label{project-management}}

One of the biggest challenges turned out to be non-technical. Project
management even with only one person can be difficult, as it requires a
great amount of self-discipline. Luckily, there were some tools and
processes that helped with this task.

\hypertarget{product-development}{%
	\subsection{Product development}\label{product-development}}

The most important thing I learned from project management was
undoubtedly how to reliably conduct product development. When I started
developing Notipie, I had a very vague vision of what the finish product
will provide. The essential functionality was interleaved with features
that could not be implemented without the essentials.

That is when I decided to streamline the development and set a
constraint of what needs to be done in order to consider the product
usable. I defined the \textbf{Minimally Viable Product} and prioritized
the issues\footnote{Issues with the MVP milestone, retrieved 2022-05-29.
	\url{https://github.com/blazejsewera/notipie/issues?q=is\%3Aissue+milestone\%3AMVP}}.

\hypertarget{minimally-viable-product}{%
	\subsubsection{Minimally Viable
		Product}\label{minimally-viable-product}}

The definition is as follows\footnote{MVP milestone, retrieved
	2022-05-29. \url{https://github.com/blazejsewera/notipie/milestone/1}}:

\begin{quote}
	Notifications can be sent with a manually programmed script with the
	help of a library. They arrive to the user interface in real time.
	
	The library is provided in the MVP.\\
	The backend correctly forwards those notifications to the frontend.\\
	The backend stores existing notifications on the disk.\\
	The frontend correctly presents notifications to the user.
\end{quote}

\hypertarget{project-board}{%
	\subsection{Project board}\label{project-board}}

One of the great tools that helped with the project management was the
new Github Project board, which is currently in beta\footnote{Github
	Projects (beta) documentation, retrieved 2022-05-29.
	\url{https://docs.github.com/en/issues/trying-out-the-new-projects-experience/about-projects}}.
The Kanban board\footnote{Kanban board -- article on Wikipedia,
	retrieved 2022-05-29. \url{https://en.wikipedia.org/wiki/Kanban_board}}
consists of four sections (columns):

\begin{itemize}
	\tightlist
	\item
	      Todo
	\item
	      Open
	\item
	      In Progress
	\item
	      Done
\end{itemize}

Section \textbf{Todo} consists of all the issues connected to this
project that are planned to be worked on in the future.

Section \textbf{Open} consists of issues that need to be worked on next.
Those are usually one to three issues that need to be done in a certain
order.

Section \textbf{In Progress} contains issues that are currently being
worked on. There is usually only one issue in this column.

Section \textbf{Done} consists of all the finished issues, as well as
the issues that were decided to be unnecessary. In that case, the issues
are marked with a \texttt{wontfix} label.

\hypertarget{backend-core}{%
	\section{Backend (core)}\label{backend-core}}

The backend's code is in the \texttt{core} directory\footnote{The
	\texttt{core} directory, retrieved 2022-05-31.
	\url{https://github.com/blazejsewera/notipie/tree/master/core}}.

\hypertarget{core-project-architecture}{%
	\subsection{Core project architecture}\label{core-project-architecture}}

The project on the top-level is structured over 4 directories:

\begin{itemize}
	\tightlist
	\item
	      \texttt{cmd} -- entry point to the application (\texttt{main})
	\item
	      \texttt{internal} -- application-specific code
	\item
	      \texttt{pkg} -- reusable utils, not specific to the application
	\item
	      \texttt{test} -- black box integration test code
\end{itemize}

\hypertarget{the-internal-directory}{%
	\subsubsection{\texorpdfstring{The \texttt{internal}
		directory}{The internal directory}}\label{the-internal-directory}}

Application-specific code is split into 5 directories representing the
levels of abstraction:

\begin{itemize}
	\tightlist
	\item
	      \texttt{domain} -- business logic, defines data structures and
	      communication of domain objects on the highest level of abstraction,
	\item
	      \texttt{grid} -- lower level of abstraction than domain, defines
	      proxies that convert network models into domain models, creates and
	      organizes domain objects into a grid, in which those objects can
	      communicate,
	\item
	      \texttt{impl} -- implements network endpoints, WebSockets, and
	      persistence,
	\item
	      \texttt{infra} -- configures the application and sets up the context
	      for DI,
	\item
	      \texttt{model} -- defines network data models.
\end{itemize}

\hypertarget{go-in-core}{%
	\subsection{Go in core}\label{go-in-core}}

Go is quickly gaining popularity among developers, with its great
tooling, focus on microservices, and state-of-the-art standard library.

\hypertarget{motivation}{%
	\subsubsection{Motivation}\label{motivation}}

When choosing the right language for the project, I focused on finding
the right tool for the application and developer experience.

I wanted \texttt{notipie} to be a high-performance microservice, so I
did not take interpreted languages like Python or JavaScript into
consideration. I mostly considered Java, Kotlin, Rust, and Go.

Java, although popular, does not have the greatest developer experience.
Things like \texttt{equals} and \texttt{hashCode} are unnecessary bloat
in the code. Project Lombok fixes some of them, but the tooling is
limited to IntelliJ, you have to download a lot of libraries for dealing
with JSON, create your own code style guide, and perform a fair bit of
setup.

Kotlin, far better than Java, but also locked-in to IntelliJ with
tooling, was an interesting option for me, but not ideal.

Rust was too low-level for my application. Explicit memory management,
although performant, was simply too verbose and work-intensive for my
use case.

Go was a perfect option. A plethora of great tooling, like first-party
Go plugin for VSCode, GoLand from JetBrains, community plugins for
Neovim, all working great and providing a good developer experience.
Furthermore, extraordinary performance of the tooling itself, with tests
running in under a second, super-fast compiler, one of the best standard
libraries I have seen, and overall simplicity of the language, made the
choice obvious.

\hypertarget{how-did-go-make-the-development-easier}{%
	\subsubsection{How did Go make the development
		easier}\label{how-did-go-make-the-development-easier}}

\hypertarget{built-in-language-features}{%
	\paragraph{Built-in language
		features}\label{built-in-language-features}}

The feature that helped the most during development was channels and
\emph{goroutines}, coroutines automatically managed by the Go runtime.
The idea behind those was very simple to understand, and working with
concurrent programming was a little bit easier.

\hypertarget{standard-library}{%
	\paragraph{Standard library}\label{standard-library}}

Standard \texttt{testing} package provides a unified, and simple tooling
for testing. I did not have to think anything about test setup. No
custom scripts, third-party libraries, or IDE setup. All I needed to do
was to name a file with \texttt{\_test.go} suffix, write a function
starting with \texttt{Test}, and run \texttt{go\ test\ ./...}. Both
VSCode with Go plugin, and GoLand automatically picked up the test setup
and I was ready to develop with TDD.

Standard \texttt{net/http} package provides everything needed for
setting up REST endpoints. Although I used Gin\footnote{Gin web
	framework, retrieved 2022-05-31. \url{https://gin-gonic.com}} for
this, due to a simpler interface, I used status codes and HTTP client
implementation from \texttt{net/http}.

\hypertarget{third-party-libraries}{%
	\paragraph{Third-party libraries}\label{third-party-libraries}}

Gin was great for writing REST endpoints, with \texttt{gin.Context}
having easy access to standard-library-compatible fields, making it
easily pluggable to other third-party libraries, like Gorilla
WebSocket\footnote{Gorilla WebSocket implementation, retrieved
	2022-05-31. \url{https://github.com/gorilla/websocket}}.

Zap\footnote{Zap, the logging library, retrieved 2022-05-31.
	\url{https://github.com/uber-go/zap}} provided an excellent and
performant way to log things in the backend. Structured logging,
automatic serialization to JSON in production mode, and human-readable
format in debug mode, paired with low or zero-allocation overhead, made
it a perfect choice for logging in a microservice.

\hypertarget{frontend-ui}{%
	\section{Frontend (ui)}\label{frontend-ui}}

\hypertarget{ui-design}{%
	\subsection{UI Design}\label{ui-design}}

When designing the UI of Notipie, I tried to maximize usability, and
minimize complexity of the interface.

\hypertarget{inspirations}{%
	\subsubsection{Inspirations}\label{inspirations}}

My main inspirations for the interface were Apple Human Interface
Guidelines\footnote{Apple Human Interface Guidelines, retrieved
	2022-05-31.
	\url{https://developer.apple.com/design/human-interface-guidelines/}}
and Google's Material Design\footnote{Google's Material Design,
	retrieved 2022-05-31. \url{https://material.io}}, but by far the most
inspiration was taken from Github Primer\footnote{Github Primer,
	retrieved 2022-05-31. \url{https://primer.style}}.

I tried to break down what is useful, what is unnecessary in my project,
and extract only the essentials for my design.

\hypertarget{final-design}{%
	\subsubsection{Final design}\label{final-design}}

\hypertarget{the-card}{%
	\paragraph{The card}\label{the-card}}

The card is a building block for the entire user interface. It provides
the most interaction in the whole application, therefore it had to be
designed with clearly laid out information and intuitive controls.

\begin{figure}
	\centering
	\includegraphics[width=8cm,height=\textheight]{./img/card_labeled.png}
	\caption{The card with labeled elements}
\end{figure}

The card itself consists of several elements:

\begin{enumerate}
	\tightlist
	\item
	      logo, it can be an image or automatically generated SVG from the first
	      two letters of the app's name,
	\item
	      indicator, whether the notification has been seen or not,
	\item
	      title of the notification,
	\item
	      subtitle,
	\item
	      body, that collapses after it reaches a certain length, so that an
	      ellipsis appears (\texttt{{[}...{]}}),
	\item
	      information about what app sent the notification and when it happened,
	\item
	      controls to archive, mark as read, or go to external site connected
	      with the notification, like a certain build on Jenkins, or the
	      notification page on Github.
\end{enumerate}

\begin{figure}
	\centering
	\includegraphics[width=8cm,height=\textheight]{./img/card_guides.png}
	\caption{The card with guides}
\end{figure}

The card was also designed with aesthetics in mind. All elements were
carefully positioned and aligned, so they are not only pleasant to look
at, but also have some features important for visual communication:

\begin{itemize}
	\tightlist
	\item
	      the rounded corners take the focus away from the card frame, and
	      provide a natural, neutral enclosure for the notification,
	\item
	      the inner padding is of equal size in each direction to provide
	      optical stability,
	\item
	      the distance between the logo and title -- subtitle combo is the same
	      size as the padding, making the logo appear centered,
	\item
	      the title -- subtitle combo itself is centered vertically relative to
	      the logo,
	\item
	      the distances between the logo, notification body, and app name --
	      timestamp combo are shorter in order to make the inner section more
	      connected,
	\item
	      the controls are centered relative to the app name -- timestamp combo,
	\item
	      the \emph{unread} indicator is unobtrusive enough not to steal all the
	      focus from the card's content,
	\item
	      finally, the \emph{unread} indicator is positioned slightly outside
	      the inner section, so that it belongs to the card itself, not its
	      content, therefore it is easier to spot at a glance.
\end{itemize}

\hypertarget{ui-component-library}{%
	\subsection{UI component library}\label{ui-component-library}}

When choosing the library for the UI components, I considered:

\begin{itemize}
	\tightlist
	\item
	      React\footnote{React, retrieved 2022-05-31. \url{https://reactjs.org/}},
	\item
	      Vue.js\footnote{Vue.js, retrieved 2022-05-31. \url{https://vuejs.org/}},
	      and
	\item
	      Angular\footnote{Angular, retrieved 2022-05-31.
	      	\url{https://angular.io/}}.
\end{itemize}

All those libraries are very popular, so I chose React, because I had
the most experience with it in my professional work.

\hypertarget{ui-networking}{%
	\subsection{UI networking}\label{ui-networking}}

The nature of notifications required me to use both REST data fetching
and asynchronous data pushes from the backend. For the latter, I decided
to use WebSockets, a standard defined in RFC6455\footnote{RFC6455,
	retrieved 2022-05-31.
	\url{https://www.rfc-editor.org/rfc/rfc6455.html}}, and
RxJS\footnote{RxJS, retrieved 2022-05-31. \url{https://rxjs.dev/}}, an
implementation of ReactiveX library\footnote{ReactiveX library,
	retrieved 2022-05-31. \url{https://reactivex.io/}}.

\hypertarget{rest-data-fetching}{%
	\subsubsection{REST data fetching}\label{rest-data-fetching}}

I used simple REST\footnote{REST definition, MDN Web Docs, retrieved
	2022-05-31.
	\url{https://developer.mozilla.org/en-US/docs/Glossary/REST}} requests
for fetching the notifications that are already on the backend server.
The standard Fetch browser API\footnote{Fetch browser API, retrieved
	2022-05-31.
	\url{https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API}} was
sufficient for the task.

\hypertarget{reactive-raven}{%
	\subsubsection{Reactive Raven}\label{reactive-raven}}

This project\footnote{Reactive Raven, retrieved 2022-05-31.
	\url{https://github.com/blazejsewera/reactive-raven}} was an
experiment on using RxJS for all real-time data fetching, enabling the
separation of concerns in the code, and decoupling the state management
implementation from the networking implementation.

When searching for the optimal solution for pushing the data to the UI,
I came across two major solutions:

\begin{itemize}
	\tightlist
	\item
	      Redux Thunks -- okay for fetching some data on user interaction,
	      e.g.~on a button click, but it provides virtually full implementation
	      lock-in, and very little separation of concerns. Fetching data is an
	      action dispatched on a store, so external communication and storing
	      data are dependent on each other.
	\item
	      Redux Sagas -- good for managing side effects with plain JavaScript,
	      but they use generator functions that yield a different type every
	      time, so they are very problematic to use with strict TypeScript.
\end{itemize}

Both thunks and sagas did not provide the separation of concerns I
wanted to achieve. Fetching or acting upon pushed data is a different
concern than storing it.

As a user, I should not have to dispatch an action on a store, when I
want to fetch data. Of course, the data can be immediately stored after
fetching, but this behavior should be injected later, so that there is
no store implementation lock-in.

This separation of concerns enabled me to migrate from Redux to Zustand
as my \emph{store} implementation, as described in the next section.

\hypertarget{state-management-in-ui}{%
	\subsection{State management in UI}\label{state-management-in-ui}}

To simplify the frontend code, I needed to use a single source of truth
for the data. I used both Redux\footnote{Redux, retrieved 2022-05-31.
	\url{https://redux.js.org/}}, and Zustand\footnote{Zustand, retrieved
	2022-05-31. \url{https://github.com/pmndrs/zustand}} for this task as
\emph{store} implementations, and Zustand came on top as a simpler
solution for my application.

\hypertarget{redux}{%
	\subsubsection{Redux}\label{redux}}

Redux is great for big applications with lots of components. Being one
of the most popular state management libraries for React, it was my
first choice.

Unfortunately, it required me to write a lot of boilerplate code, and
thus was not easily maintainable for a smaller project like Notipie.

\hypertarget{zustand}{%
	\subsubsection{Zustand}\label{zustand}}

Zustand is a lot simpler than Redux, requires a lot less boilerplate
code, and was sufficient for my application. I migrated to it in commit
\texttt{7677d13}\footnote{commit \texttt{7677d13}, retrieved 2022-05-31.
	\url{https://github.com/blazejsewera/notipie/commit/7677d1335d23994d3563d7672982b5aaf72fbbca}},
and it reduced the lines of code by over 200. I did not however give up
the connected components, as they provide better testability and
separation of concerns, which is worth a bit extra code for that.

\hypertarget{typescript-in-ui}{%
	\subsection{TypeScript in UI}\label{typescript-in-ui}}

I decided to use TypeScript in my project for the frontend part because
of its type checking tools, huge popularity, and a growing demand for in
on the job market.

\hypertarget{choosing-the-language}{%
	\subsubsection{Choosing the language}\label{choosing-the-language}}

When choosing which language to use in the UI, I considered a couple of
options:

\begin{itemize}
	\tightlist
	\item
	      plain JavaScript,
	\item
	      TypeScript,
	\item
	      Elm, and
	\item
	      CoffeeScript.
\end{itemize}

I immediately discarded the last two, due to their smaller popularity
compared to JavaScript or TypeScript.

The featureset of the language was also very important to me. JavaScript
is by far the most popular, but it lacks type annotations or pre-runtime
type checking. TypeScript and Elm turned out to be winners in the type
checking toolchain.

TypeScript also has a big advantage of being very similar to plain
JavaScript, so the transpiled code is very readable.

A big factor was general trend of language's popularity growth.
TypeScript was a clear winner in this scenario, being third most loved
language and second most wanted language in the Stack Overflow Developer
Survey 2021\footnote{Stack Overflow Developer Survey 2021, retrieved
	2022-05-31.
	\url{https://insights.stackoverflow.com/survey/2021\#most-loved-dreaded-and-wanted-language-want}}.
It was only beaten by Rust and Clojure in the \emph{Most Loved} section,
both of which are non-frontend languages, and Python in the \emph{Most
Wanted} section, which is also not a frontend language.

Another report confirming the growing popularity of TypeScript is Github
Octoverse Report 2021\footnote{Github Octoverse Report 2021, retrieved
	2022-05-31.
	\url{https://octoverse.github.com/\#top-languages-over-the-years}}.
Since 2017 it beat Ruby, C, C++, C\#, Shell, and PHP and is, as of 2021,
fourth top language on Github.

\hypertarget{working-with-typescript}{%
	\subsubsection{Working with TypeScript}\label{working-with-typescript}}

Starting with TypeScript was fairly easy, the toolchain was included in
the project creation scripts. Most dependencies had good TypeScript
annotations, or they were completely written in TypeScript, which was
very helpful for maintaining type safety.

Learning the language was also very easy. I was already familiar with
JavaScript, so I only needed to learn the type annotations, which were
very intuitive to use.

\hypertarget{build-system}{%
	\subsection{Build system}\label{build-system}}

For the build and bundle software, I wanted to use something modern,
with hot module reloading, easy to use setup scripts, customizable
development server, and short bundle times.

\hypertarget{snowpack-and-vite}{%
	\subsubsection{Snowpack and Vite}\label{snowpack-and-vite}}

I started with Snowpack\footnote{Snowpack, retrieved 2022-05-31.
	\url{https://www.snowpack.dev}} and used it until I decided to move to
Vite\footnote{Vite, retrieved 2022-05-31. \url{https://vitejs.dev}} in
commit \texttt{c11bc35}\footnote{commit \texttt{c11bc35}, retrieved
	2022-05-31.
	\url{https://github.com/blazejsewera/notipie/commit/c11bc35370f512f35d522a55fcd216c1c80ea75a}}.

Snowpack offered both hot module reloading and short bundle times,
however, there were some minor problems from time to time, the project
had a slow development, and the alternative, Vite did not seem to have
those problems.

I tried Vite in my other project, Reactive Raven\footnote{Reactive
	Raven, retrieved 2022-05-31.
	\url{https://github.com/blazejsewera/reactive-raven}}, and the
integration with React, TypeScript, Tailwind CSS, and other tools I used
was seamless, therefore I decided to migrate to it in Notipie as well.

On April 20th, 2022, Snowpack's maintainer stated in the project's
Readme document (commit \texttt{45456aa})\footnote{project's Readme
	document (commit \texttt{45456aa}), retrieved 2022-05-31.
	\url{https://github.com/FredKSchott/snowpack/blob/45456aa14978460afcb5ce20f7296556d22c7595/README.md}}
that they would no longer maintain the project and mentioned Vite as a
good alternative for it.
